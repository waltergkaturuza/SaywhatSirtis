import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/lib/auth"
import { prisma } from "@/lib/prisma"

export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session) return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 })
    
    const roles: string[] = (session.user as any)?.roles || []
    const canView = roles.some(r => ["ADMIN","SUPER_ADMIN","SYSTEM_ADMINISTRATOR","ADVANCE_USER_2","HR","MEAL_ADMIN"].includes(r))
    if (!canView) return NextResponse.json({ success: false, error: "Forbidden" }, { status: 403 })

    // Get analytics data for reports
    const analytics = await prisma.$queryRaw<any[]>`
      SELECT 
        COUNT(*) as total_submissions,
        COUNT(DISTINCT ms.form_id) as active_forms,
        COUNT(DISTINCT ms.project_id) as total_projects,
        ROUND(
          COUNT(CASE WHEN ms.metadata->>'status' = 'completed' THEN 1 END) * 100.0 / NULLIF(COUNT(*), 0), 1
        ) as completion_rate
      FROM public.meal_submissions ms
    `

    const regionalData = await prisma.$queryRaw<any[]>`
      SELECT 
        CASE 
          WHEN ms.metadata->>'country' IS NOT NULL AND ms.metadata->>'country' != 'Unknown' THEN ms.metadata->>'country'
          WHEN ms.metadata->>'region' IS NOT NULL AND ms.metadata->>'region' != 'Unknown' THEN ms.metadata->>'region'
          WHEN ms.metadata->>'city' IS NOT NULL AND ms.metadata->>'city' != 'Unknown' THEN ms.metadata->>'city'
          WHEN ms.latitude IS NOT NULL AND ms.longitude IS NOT NULL THEN 
            CASE 
              WHEN ms.latitude BETWEEN -18 AND -15 AND ms.longitude BETWEEN 30 AND 33 THEN 'Harare Province'
              WHEN ms.latitude BETWEEN -40 AND -35 AND ms.longitude BETWEEN 140 AND 150 THEN 'Victoria, Australia'
              ELSE 'GPS Location'
            END
          ELSE 'Unknown'
        END as region,
        COUNT(*) as submission_count
      FROM public.meal_submissions ms
      GROUP BY 
        CASE 
          WHEN ms.metadata->>'country' IS NOT NULL AND ms.metadata->>'country' != 'Unknown' THEN ms.metadata->>'country'
          WHEN ms.metadata->>'region' IS NOT NULL AND ms.metadata->>'region' != 'Unknown' THEN ms.metadata->>'region'
          WHEN ms.metadata->>'city' IS NOT NULL AND ms.metadata->>'city' != 'Unknown' THEN ms.metadata->>'city'
          WHEN ms.latitude IS NOT NULL AND ms.longitude IS NOT NULL THEN 
            CASE 
              WHEN ms.latitude BETWEEN -18 AND -15 AND ms.longitude BETWEEN 30 AND 33 THEN 'Harare Province'
              WHEN ms.latitude BETWEEN -40 AND -35 AND ms.longitude BETWEEN 140 AND 150 THEN 'Victoria, Australia'
              ELSE 'GPS Location'
            END
          ELSE 'Unknown'
        END
      ORDER BY submission_count DESC
      LIMIT 10
    `

    // Generate mock reports based on current data
    const reports = [
      {
        id: '1',
        name: 'Monthly MEAL Report - January 2024',
        type: 'monthly',
        project: 'All Projects',
        lastGenerated: new Date().toISOString().split('T')[0],
        nextScheduled: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        status: 'generated',
        format: 'pdf',
        recipients: ['donor@example.com', 'program@example.com'],
        autoGenerated: true,
        data: {
          totalSubmissions: analytics[0]?.total_submissions || 0,
          completionRate: analytics[0]?.completion_rate || 0,
          regionalData: regionalData
        }
      },
      {
        id: '2',
        name: 'Quarterly Performance Summary',
        type: 'quarterly',
        project: 'All Projects',
        lastGenerated: new Date(Date.now() - 15 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        nextScheduled: new Date(Date.now() + 75 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        status: 'scheduled',
        format: 'excel',
        recipients: ['management@example.com'],
        autoGenerated: true,
        data: {
          totalSubmissions: analytics[0]?.total_submissions || 0,
          completionRate: analytics[0]?.completion_rate || 0,
          regionalData: regionalData
        }
      },
      {
        id: '3',
        name: 'Community Water Program - BIODATA Report',
        type: 'custom',
        project: 'Community Water Program',
        lastGenerated: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        nextScheduled: null,
        status: 'generated',
        format: 'pdf',
        recipients: ['water-program@example.com'],
        autoGenerated: false,
        data: {
          totalSubmissions: analytics[0]?.total_submissions || 0,
          completionRate: analytics[0]?.completion_rate || 0,
          regionalData: regionalData
        }
      }
    ]

    const convertBigInt = (obj: any): any => {
      if (obj === null || obj === undefined) return obj
      if (typeof obj === 'bigint') return Number(obj)
      if (Array.isArray(obj)) return obj.map(convertBigInt)
      if (typeof obj === 'object') {
        const out: any = {}
        for (const [k, v] of Object.entries(obj)) out[k] = convertBigInt(v)
        return out
      }
      return obj
    }

    return NextResponse.json({ 
      success: true, 
      data: convertBigInt(reports),
      total: reports.length
    })
  } catch (e) {
    console.error("MEAL reports fetch error", e)
    return NextResponse.json({ success: false, error: "Failed to fetch reports" }, { status: 500 })
  }
}

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session) return NextResponse.json({ success: false, error: "Unauthorized" }, { status: 401 })
    
    const roles: string[] = (session.user as any)?.roles || []
    const canCreate = roles.some(r => ["ADMIN","SUPER_ADMIN","SYSTEM_ADMINISTRATOR","MEAL_ADMIN"].includes(r))
    if (!canCreate) return NextResponse.json({ success: false, error: "Forbidden" }, { status: 403 })

    const body = await req.json()
    const { name, type, project, format, recipients, autoGenerated } = body

    // Create new report
    const newReport = {
      id: Date.now().toString(),
      name,
      type,
      project,
      lastGenerated: null,
      nextScheduled: autoGenerated ? new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] : null,
      status: 'scheduled',
      format,
      recipients: recipients || [],
      autoGenerated: autoGenerated || false,
      createdBy: session.user?.name || 'Unknown',
      createdAt: new Date().toISOString()
    }

    // Here you would typically save to a reports table
    // For now, we'll return success

    return NextResponse.json({ 
      success: true, 
      data: newReport,
      message: "Report created successfully"
    })
  } catch (e) {
    console.error("MEAL report creation error", e)
    return NextResponse.json({ success: false, error: "Failed to create report" }, { status: 500 })
  }
}
